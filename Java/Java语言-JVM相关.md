# JVM相关

## 目录

1. 介绍一下Class文件
2. Java虚拟机运行时的数据区
3. 双亲委派模型
4. 判断Java中对象存活的算法
5. JVM垃圾回收算法

* 介绍一下Class文件

Java诞生之初，Java的规范就拆分为Java语言规范和Java虚拟机规范，为了实现Java语言的平台无关性，各种不同平台的虚拟机都统一使用的程序存储格式，也就是字节码。使用Java编译器可以把Java代码编译成为存储字节码的Class文件。Class文件是一组以8个字节为基础单位的二进制流，每一个Class文件都对应着唯一一个类或接口的定义信息。

* Java虚拟机运行时的数据区

分为 **程序计数器**，**Java虚拟机栈**，**本地方法栈**，**Java堆**，**方法区**

**程序计数器**是线程私有的一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Natvie方法，这个计数器值为空。

**Java虚拟机栈**线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型。每个方法执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的调用和执行完成，就对应着栈帧的入栈和岀栈过程。其中局部变量表存放的是编译器可知的各种基本数据类型，对象引用和returnAddress类型。这里规定了两种异常情况，如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverFlow异常；如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，会抛出OutOfMemoryError。

**本地方法栈**与Java虚拟机栈类似，区别就是这里执行的是native方法。

**Java堆** 是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。此内存区域的唯一目的就是存放对象实例，几乎所有的对象是你都在这里分配内存。这里也是垃圾收集器管理的主要区域，也成做GC堆。由于现代收集器基本都采用分代算法，所以Java堆还可以细分为：新生代和老年代。Java堆可以是物理上不连续的内存空间，只要逻辑连续即可。如果Java堆中没有内存完成实例分配，并且堆也无法拓展时，将抛出OutOfMemiryError。

**方法区** 也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。其中**运行时常量池**是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。当方法区无法满足内存分配需求时，将会抛出OutOfMemiryError。

* 双亲委派模型

双亲委派模型指的是Java虚拟机执行类加载的时候，设计的一套类加载器的加载模型。
Java虚拟机把描述类的class文件加载到内存,并对数据进行校验，转换解析和初始化，最终形成被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。
从Java虚拟机的角度，存在两种不同的类加载器，一种是启动类加载器，由C++语言实现，是虚拟机的一部分。另一类是其他类加载器，由Java语言实现，独立于虚拟机外部，继承自ClassLoader抽象类。
类加载器存在层次关系，最高层是启动类加载器，然后由上到下是扩展类加载器，应用程序类加载器以及各种自定义的类加载器。双亲委派模型的工作流程是，如果一个类加载器收到了类加载的请求，它首先不会自动去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。

* 判断Java中对象存活的算法

1. 引用计数器算法：

引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了。
引用计数器实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是A,B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法已经不再使用了。

2. 根搜索方法：

根搜索方法是通过一些“GCRoots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被GCRoots的引用链连接的时候，说明这个对象是不可用的。

* JVM垃圾回收算法

1. 标记-清除算法

标记-清除（Mark-Sweep）算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在清除阶段，清除所有未被标记的对象。

缺点：
1、效率问题，标记和清除两个过程的效率都不高；
2、空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

2. 标记整理算法

标记整理算法类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

缺点：
1、效率问题，（同标记清除算法）标记和整理两个过程的效率都不高；

优点：
1、相对标记清除算法，解决了内存碎片问题。
2、没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。

3. 复制算法

复制算法可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可

优点
效率高，没有内存碎片

缺点：
1、浪费一半的内存空间
2、复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。

4. 分代收集算法

当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法，在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。

对象分配策略：

对象优先在Eden区域分配，如果对象过大直接分配到Old区域。
长时间存活的对象进入到Old区域。

改进复制算法：
现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor 。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。