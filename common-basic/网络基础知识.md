# 网络基础知识

## 目录

1. GET和POST的区别
2. Cookie和Session的区别
3. Http和Https的区别
4. Https的混合加密机制的原理
5. TCP和UDP的区别
6. TCP建立连接和断开连接的过程
7. TCP/IP协议的含义和分层
8. 浏览器输入URL后发生了什么

## GET和POST的区别

GET和POST是http发送请求的两种方法。两者的区别通常说的是语义上的区别，而不是语法上，根据征求意见稿(RFC)，GET方法用于获取已被URI识别的资源，而POST方法是根据请求负荷（报文主体），对指定的资源做出处理。在实际应用场景中，GET请求的参数通常是放在url后面，POST请求的参数通常是放在requestBody里，后者更适合传输敏感性的参数。

值得一提的是，遵循RESTFUL的架构风格的API通常把GET方法定义为获取资源的操作，POST方法作为新建资源的操作。

## Cookie和Session的区别

session机制是一种服务器端的机制。由于HTTP协议是无状态的协议,所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户。这个机制就是Session。Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；维持一个会话的核心就是客户端的唯一标识，即 session id。


Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器，通常是通过扩展HTTP协议来实现的，它存在于http协议中的header字段里，是客户端保存用户信息的一种机制,用来记录用户的一些信息。在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。

Session通常要借助Cookie来实现Session id。

## Http和Https的区别

* HTTP的不安全性，明文传输被窃听，无法验证身份被伪装，无法证明报文完整被篡改。
* HTTPS并非一种新协议，只是HTTP通信接口部分用SSL/TLS协议代替。通常HTTP直接和TCP通信，当使用SSL的时候，则演变成先和SSL通信，再和TCP通信。也就是说HTTPS本身是披着SSL外壳的HTTP
* HTTPS采用的是混合加密机制。加密的方式可以分为共享密钥加密和使用两把密钥的公开加密。前者加密和解密使用同一个密钥，也成为对称加密。后者使用一对非对称密钥，一把叫做私有密钥，一把叫做公开密钥。前者加解密的速度更快，但密钥传输的安全性不高。后者安全性很高，但会影响加密解密的速度。HTTPS使用的是混合加密机制。利用公开密钥加密来传输共享密钥，然后用共享密钥实现请求加密和解密。兼顾速度和安全性。
* (进一步) 为了确保公开密钥的合法性，需要使用数字证书认证机构(CA)提供的安全证书。
由于HTTPS引入了SSL/TLS层的加密解密的处理步骤，所以HTTPS请求相对会消耗更多的服务器和客户端资源，整体通信量会增加。

# Https的混合加密机制的原理

HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

[也许，这样理解HTTPS更容易](https://showme.codes/2017-02-20/understand-https/)

## TCP和UDP的区别

TCP和UDP都是TCP/IP协议层中传输层的代表协议,TCP是传输控制协议(Transmission Control Protocol)，是一种面向连接的、可靠的、基于字节流的传输层通信协议。
UDP是面向无连接，不具有可靠性的用户数据报协议(User Data Protocol)

* TCP协议面向连接，是流传输协议，通过连接发送数据，而UDP协议传输不需要连接，是数据报协议
* TCP为可靠传输协议，而UDP为不可靠协议。即TCP协议可以保证数据的完整和有序，而UDP不能保证
* UDP由于不需要连接，故传输速度比TCP快，且占用资源比TCP少。
* 应用场合：TCP协议常用在对数据文件完整性较高的一些场景中，如文件传输等。UDP常用于对通讯速度有较高要求时，如直播，视频通话等。

## TCP建立连接和断开连接的过程

TCP建立连接的方式俗称为『三次握手』，而断开连接的方式俗称为『四次挥手』

所谓『三次握手』，是指建立TCP连接的服务器和客户端的双方，通过发送三次报文的形式，建立起TCP连接。而『四次挥手』，是指断开TCP连接的服务器和客户端的双方，通过发送四次报文的形式，断开TCP连接。

TCP协议首部有Sequence Number序列号和Acknowledgment Number确认序列号，分别用于解决报文乱序和丢包的问题。
TCP协议首部中有6个标志比特，用于操控TCP状态，其中ACK，SYN，FIN这三个标志位在建立和断开TCP连接中发挥重要作用。ACK标志表示应答域有效，1表示有效，0表示无效。SYN表示同步序号，建立连接时和ACK标志搭配使用。FIN表示发送端已经到达数据末尾，用于断开数据连接。

我们先说『三次握手』，
* 第一次握手，客户端发送请求报文段，其中SYN位 置为1，并携带上序列号，发送后客户端进去SYN_SEND状态，等待服务器的确认。
* 第二次握手，服务器收到SYN报文后进行确认，将SYN位 置为1，ACK位 置为序列号+1，并携带上新的序列号发送报文给客户端，此时服务器进去SYN_RECV状态。
* 第三次握手，客户端收到服务器的SYN+ACK报文段，将确认序列号置为序列号+1，向服务器发送ACK报文段。发送完成后，客户端和服务端都进入了建立成功状态。
完成三次握手后，客户端和服务器就可以开始传送数据。

再来说『四次挥手』，
* 第一次挥手，任意一端，称为主机1,设置序列号和确认序列号，向主机2发送一个FIN报文段，此时发送方进入FIN_WAIT_1状态。表示主机1没有要发给主机2的数据了。
* 第二次挥手，主机2收到主机1发送的FIN报文段后，向主机1回一个ACK报文段。序列号和确认序列号都+1。主机1进入FIN_WAIT_2状态。表示主机2同意主机1的关闭请求。
* 第三次挥手，主机2再次向主机1发送FIN报文段，请求关闭链接，此时主机2进入LAST_ACK状态。
* 第四次挥手，主机1收到了主机2的FIN报文段后，向主机2发送ACK报文段，然后主机1进入了TIME_WAIT状态，主机2收到主机1的ACK报文段后，就关闭链接。此时主机1等待一会后么有收到回复，表示主机2已经关闭，主机1也会关闭。

为什么要三次握手?

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

为什么要四次挥手？

第一次挥手的时候，主机1表示没有需要发送给主机2的数据了，但是主机1还是可以接收主机2的数据。第二次挥手只是表示主机2知道了主机1没有数据要发了，但此时，主机2还是可以发送数据给主机1的。

## TCP/IP协议的含义和分层

* TCP/IP的具体含义通常指的是利用IP进行通信时所必须用到的协议群的总称。具体来说，像IP和ICMP，TCP和UDP，TELENT和FTP，以及HTTP等都属于TCP/IP的协议。

* 基于OSI模型，TCP/IP的层次可以分为七层，分别是物理层，数据链路层，网络层，传输层。会话层，表示层，应用层。

* 硬件层是最底层负责数据传输的硬件，以电压的高低，光的闪灭以及电波的强弱等信号作为传输媒介。
* 数据链路层则是负责以二进制0，1来表示和传输信息。这一层代表性的是MAC地址(6字节，48比特)，可以在同一种互连的数据链路节点中进行包传递。
* 而一旦跨越多种数据链路，就需要网络层。网络层的的代表性协议是IP协议，基于IP地址进行数据的分组交换。IP地址(ipv4 4*2^3 如 192.168.0.1, ipv6 128比特，16个字节)，路由，IP的分包和组包是IP的三大作用模块。DNS系统可以维护内部主机名和IP地址的对应关系。而ARP协议可以将IP地址转换成MAC地址。
* 在网络层的上一层，是传输层。主要目的是可靠传输。这一层有两个经典的协议TCP和UDP。TCP是面向连接的可靠的流协议，而UDP是不可靠的数据抱协议。前者只有确定通信对端存在时才会发送数据，实现了各种控制功能，如丢包重发，顺序控制等。而UDP协议的高效性，适合视频通话等场景，这一层的地址是端口号(http端口号80，https端口号443)。
* 会话层，表示层，应用层这三层常见协议有www协议，html协议，http协议等。

ARP协议(网络层):  找到IP地址对应的MAC地址(IP->MAC)
RARP协议(网络层): 通过MAC地址定位IP地址(MAC->IP)
TCP协议(传输层):  面向有连接的、可靠的流协议
UDP协议(传输层):  面向无连接，不具有可靠性的用户数据报协议
DNS协议(应用层)： 提供域名(主机名)<->IP地址的互相转化

数据链路层：Mac地址
网络层：   IP地址
传输层：   端口号

## 浏览器输入URL后发生了什么

* DNS域名解析

首先，浏览器向本地 DNS 服务器发起请求，由于本地 DNS 服务器没有缓存不能直接将域名转换为 IP 地址，需要采用递归或者迭代查询的方式依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器。一般本地 DNS 地址由 ISP（Internet Service Provider，互联网服务提供商）通过 DHCP 协议动态分配，我们仍可以手动把它修改为公共 DNS，比如 Google 提供的 8.8.8.8，国内的 114.114.114.114，它们分布在不同的地理位置上，借助 Anycast 技术，将请求路由到离用户最近的 DNS 服务器上。为了让 DNS 解析更加精确，客户端还需在请求包里带上自己的源 IP 地址，否则类似 GSLB 的 DNS 服务器不能够精准地匹配判断离用户最近的目标 IP 地址。

* 建立TCP连接

* 发送HTTP请求

* 服务器处理请求

* 服务器返回响应结果

* 维持连接

完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。在 HTTP/1.1 中，Connection: keep-alive 是默认启用的，表示持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。

* 断开连接

* 浏览器解析和布局渲染

浏览器解析HTML，CSS，JS，以及加载图片视频等媒体资源。浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。

根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。

最后浏览器绘制各个节点，将页面展示给用户。